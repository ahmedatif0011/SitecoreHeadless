{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SearchQueryService = void 0;\n/**\n * @deprecated use GraphQLClient instead\n * Provides functionality for performing GraphQL 'search' operations, including handling pagination.\n * This class is meant to be extended or used as a mixin; it's not meant to be used directly.\n * @template T The type of objects being requested.\n * @mixin\n */\nclass SearchQueryService {\n  /**\n   * Creates an instance of search query service.\n   * @param {GraphQLClient} client that fetches data from a GraphQL endpoint.\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * 1. Validates mandatory search query arguments\n   * 2. Executes search query with pagination\n   * 3. Aggregates pagination results into a single result-set.\n   * @template T The type of objects being requested.\n   * @param {string | DocumentNode} query the search query.\n   * @param {SearchQueryVariables} args search query arguments.\n   * @returns {T[]} array of result objects.\n   * @throws {RangeError} if a valid root item ID is not provided.\n   * @throws {RangeError} if the provided language(s) is(are) not valid.\n   */\n  fetch(query, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!args.rootItemId) {\n        throw new RangeError('\"rootItemId\" and \"language\" must be non-empty strings');\n      }\n      if (!args.language) {\n        throw new RangeError('\"rootItemId\" and \"language\" must be non-empty strings');\n      }\n      let results = [];\n      let hasNext = true;\n      let after = '';\n      while (hasNext) {\n        const fetchResponse = yield this.client.request(query, Object.assign(Object.assign({}, args), {\n          after\n        }));\n        results = results.concat((_a = fetchResponse === null || fetchResponse === void 0 ? void 0 : fetchResponse.search) === null || _a === void 0 ? void 0 : _a.results);\n        hasNext = fetchResponse.search.pageInfo.hasNext;\n        after = fetchResponse.search.pageInfo.endCursor;\n      }\n      return results;\n    });\n  }\n}\nexports.SearchQueryService = SearchQueryService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}