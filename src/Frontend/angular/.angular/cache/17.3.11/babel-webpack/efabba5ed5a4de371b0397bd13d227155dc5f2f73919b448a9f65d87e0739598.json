{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLRequestClient = exports.DefaultRetryStrategy = void 0;\nconst graphql_request_1 = require(\"graphql-request\");\nconst url_parse_1 = __importDefault(require(\"url-parse\"));\nconst debug_1 = __importDefault(require(\"./debug\"));\nconst timeout_promise_1 = __importDefault(require(\"./utils/timeout-promise\"));\n/**\n * Represents a default retry strategy for handling retry attempts in case of specific HTTP status codes.\n * This class implements the RetryStrategy interface and provides methods to determine whether a request\n * should be retried and calculates the delay before the next retry attempt.\n */\nclass DefaultRetryStrategy {\n  /**\n   * @param {object} options Configurable options for retry mechanism.\n   * @param {number[]} [options.statusCodes] HTTP status codes to trigger retries on. Default is [429].\n   * @param {string[]} [options.errorCodes] Node error codes to trigger retries. Default is ['ECONNRESET', 'ETIMEDOUT', 'EPROTO'].\n   * @param {number} [options.factor] Factor by which the delay increases with each retry attempt. Default is 2.\n   */\n  constructor(options = {}) {\n    this.statusCodes = options.statusCodes || [429];\n    this.errorCodes = options.errorCodes || ['ECONNRESET', 'ETIMEDOUT', 'EPROTO'];\n    this.factor = options.factor || 2;\n  }\n  shouldRetry(error, attempt, retries) {\n    var _a;\n    const isStatusCodeError = ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) !== undefined && this.statusCodes.includes(error.response.status);\n    const isNodeErrorCode = error.code !== undefined && this.errorCodes.includes(error.code);\n    return retries > 0 && attempt <= retries && (isStatusCodeError || isNodeErrorCode);\n  }\n  getDelay(error, attempt) {\n    var _a;\n    const rawHeaders = (_a = error.response) === null || _a === void 0 ? void 0 : _a.headers;\n    const retryAfterHeader = rawHeaders === null || rawHeaders === void 0 ? void 0 : rawHeaders.get('Retry-After');\n    if (retryAfterHeader !== null && retryAfterHeader !== undefined && retryAfterHeader.trim() !== '') {\n      const delaySeconds = Number.parseFloat(retryAfterHeader);\n      return delaySeconds * 1000;\n    } else {\n      return Math.pow(this.factor, attempt - 1) * 1000;\n    }\n  }\n}\nexports.DefaultRetryStrategy = DefaultRetryStrategy;\n/**\n * A GraphQL client for Sitecore APIs that uses the 'graphql-request' library.\n * https://github.com/prisma-labs/graphql-request\n */\nclass GraphQLRequestClient {\n  /**\n   * Provides ability to execute graphql query using given `endpoint`\n   * @param {string} endpoint The Graphql endpoint\n   * @param {GraphQLRequestClientConfig} [clientConfig] GraphQL request client configuration.\n   */\n  constructor(endpoint, clientConfig = {}) {\n    var _a;\n    this.endpoint = endpoint;\n    this.headers = {};\n    if (clientConfig.apiKey) {\n      this.headers.sc_apikey = clientConfig.apiKey;\n    }\n    if (clientConfig.headers) {\n      this.headers = Object.assign(Object.assign({}, this.headers), clientConfig.headers);\n    }\n    if (!endpoint || !(0, url_parse_1.default)(endpoint).hostname) {\n      throw new Error(`Invalid GraphQL endpoint '${endpoint}'. Verify that 'layoutServiceHost' property in 'scjssconfig.json' file or appropriate environment variable is set`);\n    }\n    this.timeout = clientConfig.timeout;\n    this.retries = (_a = clientConfig.retries) !== null && _a !== void 0 ? _a : 3;\n    this.retryStrategy = clientConfig.retryStrategy || new DefaultRetryStrategy({\n      statusCodes: [429, 502, 503, 504, 520, 521, 522, 523, 524]\n    });\n    this.client = new graphql_request_1.GraphQLClient(endpoint, {\n      headers: this.headers,\n      fetch: clientConfig.fetch\n    });\n    this.debug = clientConfig.debugger || debug_1.default.http;\n  }\n  /**\n   * Factory method for creating a GraphQLRequestClientFactory.\n   * @param {object} config - client configuration options.\n   * @param {string} config.endpoint - endpoint\n   * @param {string} [config.apiKey] - apikey\n   */\n  static createClientFactory({\n    endpoint,\n    apiKey\n  }) {\n    return (config = {}) => new GraphQLRequestClient(endpoint, Object.assign(Object.assign({}, config), {\n      apiKey\n    }));\n  }\n  /**\n   * Execute graphql request\n   * @param {string | DocumentNode} query graphql query\n   * @param {object} [variables] graphql variables\n   * @param {RequestOptions} [options] Options for configuring a GraphQL request.\n   */\n  request(query, variables, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let attempt = 1;\n      const retryer = () => __awaiter(this, void 0, void 0, function* () {\n        // Note we don't have access to raw request/response with graphql-request\n        // (or nice hooks like we have with Axios), but we should log whatever we have.\n        this.debug('request: %o', {\n          url: this.endpoint,\n          headers: Object.assign(Object.assign({}, this.headers), options === null || options === void 0 ? void 0 : options.headers),\n          query,\n          variables\n        });\n        const startTimestamp = Date.now();\n        const fetchWithOptionalTimeout = [this.client.request(query, variables, options === null || options === void 0 ? void 0 : options.headers)];\n        if (this.timeout) {\n          this.abortTimeout = new timeout_promise_1.default(this.timeout);\n          fetchWithOptionalTimeout.push(this.abortTimeout.start);\n        }\n        return Promise.race(fetchWithOptionalTimeout).then(data => {\n          var _a;\n          (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();\n          this.debug('response in %dms: %o', Date.now() - startTimestamp, data);\n          return Promise.resolve(data);\n        }, error => __awaiter(this, void 0, void 0, function* () {\n          var _a, _b;\n          (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();\n          this.debug('response error: %o', error.response || error.message || error);\n          const status = ((_b = error.response) === null || _b === void 0 ? void 0 : _b.status) || error.code;\n          const shouldRetry = this.retryStrategy.shouldRetry(error, attempt, this.retries);\n          if (shouldRetry) {\n            const delayMs = this.retryStrategy.getDelay(error, attempt);\n            this.debug('Error: %s. Retrying in %dms (attempt %d).', status, delayMs, attempt);\n            attempt++;\n            return new Promise(resolve => setTimeout(resolve, delayMs)).then(retryer);\n          } else {\n            return Promise.reject(error);\n          }\n        }));\n      });\n      return retryer();\n    });\n  }\n}\nexports.GraphQLRequestClient = GraphQLRequestClient;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}