{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport debuggers from './debug';\nimport TimeoutPromise from './utils/timeout-promise';\nexport class NativeDataFetcher {\n  constructor(config = {}) {\n    this.config = config;\n  }\n  /**\n   * Implements a data fetcher. @see HttpDataFetcher<T> type for implementation details/notes.\n   * @param {string} url The URL to request; may include query string\n   * @param {unknown} [data] Optional data to POST with the request.\n   * @returns {Promise<HttpResponse<T>>} response\n   */\n  fetch(url, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const _b = this.config,\n        {\n          debugger: debugOverride,\n          fetch: fetchOverride\n        } = _b,\n        init = __rest(_b, [\"debugger\", \"fetch\"]);\n      const startTimestamp = Date.now();\n      const fetchImpl = fetchOverride || fetch;\n      const debug = debugOverride || debuggers.http;\n      const requestInit = this.getRequestInit(init, data);\n      const fetchWithOptionalTimeout = [fetchImpl(url, requestInit)];\n      if (init.timeout) {\n        this.abortTimeout = new TimeoutPromise(init.timeout);\n        fetchWithOptionalTimeout.push(this.abortTimeout.start);\n      }\n      // Note a goal here is to provide consistent debug logging and error handling\n      // as we do in AxiosDataFetcher and GraphQLRequestClient\n      const {\n          headers: reqHeaders\n        } = requestInit,\n        rest = __rest(requestInit, [\"headers\"]);\n      debug('request: %o', Object.assign({\n        url,\n        headers: this.extractDebugHeaders(reqHeaders)\n      }, rest));\n      const response = yield Promise.race(fetchWithOptionalTimeout).then(res => {\n        var _a;\n        (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();\n        return res;\n      }).catch(error => {\n        var _a;\n        (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();\n        debug('request error: %o', error);\n        throw error;\n      });\n      // Note even an error status may send useful json data in response (which we want for logging)\n      let respData = undefined;\n      const isJson = (_a = response.headers.get('Content-Type')) === null || _a === void 0 ? void 0 : _a.includes('application/json');\n      if (isJson) {\n        respData = yield response.json().catch(error => {\n          debug('response.json() error: %o', error);\n        });\n      }\n      const debugResponse = {\n        status: response.status,\n        statusText: response.statusText,\n        headers: this.extractDebugHeaders(response.headers),\n        url: response.url,\n        redirected: response.redirected,\n        data: respData\n      };\n      if (!response.ok) {\n        debug('response error: %o', debugResponse);\n        throw new Error(`HTTP ${response.status} ${response.statusText}`);\n      }\n      debug('response in %dms: %o', Date.now() - startTimestamp, debugResponse);\n      return Object.assign(Object.assign({}, response), {\n        data: respData\n      });\n    });\n  }\n  /**\n   * Determines settings for the request\n   * @param {RequestInit} init Custom settings for request\n   * @param {unknown} [data] Optional data to POST with the request\n   * @returns {RequestInit} The final request settings\n   */\n  getRequestInit(init = {}, data) {\n    // This is a focused implementation (GET or POST only using JSON input/output)\n    // so we are opinionated about method, body, and Content-Type\n    init.method = data ? 'POST' : 'GET';\n    init.body = data ? JSON.stringify(data) : undefined;\n    const headers = new Headers(init.headers);\n    headers.set('Content-Type', 'application/json');\n    init.headers = headers;\n    return init;\n  }\n  /**\n   * Safely extract all headers for debug logging\n   * @param {HeadersInit} incomingHeaders Incoming headers\n   * @returns Object with headers as key/value pairs\n   */\n  extractDebugHeaders(incomingHeaders = {}) {\n    const headers = {};\n    if (typeof (incomingHeaders === null || incomingHeaders === void 0 ? void 0 : incomingHeaders.forEach) !== 'string' && incomingHeaders.forEach) {\n      incomingHeaders === null || incomingHeaders === void 0 ? void 0 : incomingHeaders.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    return headers;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}