{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JssContextServerSideService = void 0;\nconst tslib_1 = require(\"tslib\");\nconst core_1 = require(\"@angular/core\");\nconst jss_context_service_1 = require(\"./jss-context.service\");\nconst JssState_1 = require(\"./JssState\");\nconst rxjs_1 = require(\"rxjs\");\nconst jss_layout_service_1 = require(\"./layout/jss-layout.service\");\nconst sitecore_jss_angular_1 = require(\"@sitecore-jss/sitecore-jss-angular\");\nconst i0 = tslib_1.__importStar(require(\"@angular/core\"));\nconst i1 = tslib_1.__importStar(require(\"./layout/jss-layout.service\"));\nconst i2 = tslib_1.__importStar(require(\"@sitecore-jss/sitecore-jss-angular\"));\nconst i3 = tslib_1.__importStar(require(\"./JssState\"));\n/**\n * Stores the JSS app's context (current route and Sitecore context data).\n * This implementation runs on the server (SSR) side; see jss-context.service.ts\n * for the implementation that runs on the client (browser) side.\n */\nlet JssContextServerSideService = /*#__PURE__*/(() => {\n  class JssContextServerSideService extends jss_context_service_1.JssContextService {\n    transferState;\n    layoutService;\n    stateService;\n    serverToSsrState;\n    constructor(transferState, layoutService, stateService,\n    // this initial state from sitecore is injected by server.bundle for \"integrated\" mode\n    serverToSsrState) {\n      super(transferState, layoutService, stateService);\n      this.transferState = transferState;\n      this.layoutService = layoutService;\n      this.stateService = stateService;\n      this.serverToSsrState = serverToSsrState;\n    }\n    changeRoute(_route, _language) {\n      // console.log('Server route change to ' + route);\n      // if the route is null we signal the JSS routing setup that a 'fetch error'\n      // occurred, so that it properly sends a not found route from SSR data\n      if (this.serverToSsrState.sitecore && !this.serverToSsrState.sitecore.route) {\n        this.serverToSsrState.routeFetchError = {\n          status: 404,\n          statusText: 'Not Found',\n          // spread in order to not have a reference to serverToSsrState, because will have a circular structure with routeFetchError\n          data: {\n            ...this.serverToSsrState\n          }\n        };\n      }\n      // read initial state from data injected via server.bundle wrapper\n      this.stateService.setState(this.serverToSsrState);\n      // place the initial state into TransferState for the client\n      this.transferState.set(jss_context_service_1.jssKey, this.serverToSsrState);\n      return (0, rxjs_1.of)(this.serverToSsrState);\n    }\n    static ɵfac = function JssContextServerSideService_Factory(t) {\n      return new (t || JssContextServerSideService)(i0.ɵɵinject(i0.TransferState), i0.ɵɵinject(i1.JssLayoutService), i0.ɵɵinject(i2.JssStateService), i0.ɵɵinject('JSS_SERVER_LAYOUT_DATA'));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: JssContextServerSideService,\n      factory: JssContextServerSideService.ɵfac\n    });\n  }\n  return JssContextServerSideService;\n})();\nexports.JssContextServerSideService = JssContextServerSideService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}