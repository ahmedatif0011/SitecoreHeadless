{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JssGraphQLService = void 0;\nconst tslib_1 = require(\"tslib\");\nconst core_1 = require(\"@angular/core\");\nconst apollo_angular_1 = require(\"apollo-angular\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst sitecore_jss_angular_1 = require(\"@sitecore-jss/sitecore-jss-angular\");\nconst jss_context_service_1 = require(\"./jss-context.service\");\nconst common_1 = require(\"@angular/common\");\nconst i0 = tslib_1.__importStar(require(\"@angular/core\"));\nconst i1 = tslib_1.__importStar(require(\"apollo-angular\"));\nconst i2 = tslib_1.__importStar(require(\"./jss-context.service\"));\n/**\n * Provides GraphQL querying services via Apollo Client.\n * This service is needed to use _connected GraphQL_ with your JSS app.\n * If you are not using GraphQL, or are only using the _integrated GraphQL_\n * that is within the Layout Service, you do not need this service.\n *\n * Compared to using apollo-angular directly, using this service:\n * * Handles Sitecore SSR issues\n * * Makes available ambient $datasource and $contextItem GQL variables based on current route data\n * * Integrates with Sitecore Experience Editor's DOM-based update needs\n *\n * The API is identical to apollo-angular's `Apollo` service otherwise.\n */\nlet JssGraphQLService = /*#__PURE__*/(() => {\n  class JssGraphQLService {\n    apollo;\n    sitecoreContext;\n    platformId;\n    isEditingOrPreviewingAndSsr;\n    constructor(apollo, sitecoreContext, platformId) {\n      this.apollo = apollo;\n      this.sitecoreContext = sitecoreContext;\n      this.platformId = platformId;\n      this.isEditingOrPreviewingAndSsr = (0, common_1.isPlatformServer)(this.platformId) && this.sitecoreContext.stateValue.sitecore.context.pageState !== 'normal';\n    }\n    static extractVariableNames(query) {\n      const variableNames = {};\n      query.definitions.map(def => def.variableDefinitions).filter(def => def).forEach(defs => defs.forEach(def => {\n        if (def.kind && def.kind === 'VariableDefinition') {\n          variableNames[def.variable.name.value] = true;\n        }\n      }));\n      return variableNames;\n    }\n    /**\n     * Executes a read query against the GraphQL endpoint\n     */\n    query(options) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return rxjs_1.EMPTY;\n      }\n      options.variables = this.addJssAmbientVariables(options.query, options.variables, options.renderingContext);\n      const observable = this.apollo.query(options);\n      // When a query reply is received, and we're in Experience Editor mode,\n      // xEditor needs to know to rebind to the editable DOM elements after they get inserted\n      // (assuming use of `jss` field in the GQL query). This accomplishes that.\n      observable.pipe((0, operators_1.first)()).subscribe(() => {\n        setTimeout(() => {\n          if ((0, sitecore_jss_angular_1.isEditorActive)()) {\n            (0, sitecore_jss_angular_1.resetEditorChromes)();\n          }\n        }, 1000);\n      });\n      return observable;\n    }\n    /**\n     * Executes a GraphQL mutation (write) against the GraphQL endpoint\n     */\n    mutate(options) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return rxjs_1.EMPTY;\n      }\n      this.addJssAmbientVariables(options.mutation, options.variables, options.renderingContext);\n      return this.apollo.mutate(options);\n    }\n    /**\n     * Executes a GraphQL subscription (real-time data) against the GraphQL endpoint\n     */\n    subscribe(options, extra) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return rxjs_1.EMPTY;\n      }\n      this.addJssAmbientVariables(options.query, options.variables, options.renderingContext);\n      return this.apollo.subscribe(options, extra);\n    }\n    addJssAmbientVariables(query, variables, rendering) {\n      if (!variables) {\n        variables = {};\n      }\n      const usedVariables = JssGraphQLService.extractVariableNames(query);\n      if (usedVariables.datasource && rendering && rendering.dataSource) {\n        variables.datasource = rendering.dataSource;\n      }\n      if (usedVariables.contextItem && this.sitecoreContext.stateValue.sitecore && this.sitecoreContext.stateValue.sitecore.route && this.sitecoreContext.stateValue.sitecore.route.itemId) {\n        variables.contextItem = this.sitecoreContext.stateValue.sitecore.route.itemId;\n      }\n      // pass language as a variable to the query, if language exists as a variable and in sitecoreContext\n      if (usedVariables.language && this.sitecoreContext.stateValue.language) {\n        variables.language = this.sitecoreContext.stateValue.language;\n      }\n      return variables;\n    }\n    static ɵfac = function JssGraphQLService_Factory(t) {\n      return new (t || JssGraphQLService)(i0.ɵɵinject(i1.Apollo), i0.ɵɵinject(i2.JssContextService), i0.ɵɵinject(core_1.PLATFORM_ID));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: JssGraphQLService,\n      factory: JssGraphQLService.ɵfac\n    });\n  }\n  return JssGraphQLService;\n})();\nexports.JssGraphQLService = JssGraphQLService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}