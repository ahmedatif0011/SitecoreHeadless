{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getJssPagesClientData = exports.handleEditorAnchors = exports.resetEditorChromes = exports.isEditorActive = exports.HorizonEditor = exports.ChromeRediscoveryGlobalFunctionName = exports.ExperienceEditor = exports.EDITING_ALLOWED_ORIGINS = exports.PAGES_EDITING_MARKER = exports.QUERY_PARAM_EDITING_SECRET = exports.DEFAULT_PLACEHOLDER_UID = void 0;\nconst is_server_1 = __importDefault(require(\"../utils/is-server\"));\n/**\n * Default value of uid for root placeholder when uid is not present.\n */\nexports.DEFAULT_PLACEHOLDER_UID = '00000000-0000-0000-0000-000000000000';\n/**\n * Query parameter for editing secret\n */\nexports.QUERY_PARAM_EDITING_SECRET = 'secret';\n/**\n * ID to be used as a marker for a script rendered in XMC Pages\n * Should identify app is in XM Cloud Pages editing mode\n */\nexports.PAGES_EDITING_MARKER = 'jss-hrz-editing';\n/**\n * Default allowed origins for editing requests. This is used to enforce CORS, CSP headers.\n */\nexports.EDITING_ALLOWED_ORIGINS = ['https://pages.sitecorecloud.io'];\n/**\n * Static utility class for Sitecore Experience Editor\n */\nclass ExperienceEditor {\n  /**\n   * Determines whether the current execution context is within a Experience Editor.\n   * Experience Editor environment can be identified only in the browser\n   * @returns true if executing within a Experience Editor\n   */\n  static isActive() {\n    if ((0, is_server_1.default)()) {\n      return false;\n    }\n    // eslint-disable-next-line\n    const sc = window.Sitecore;\n    return Boolean(sc && sc.PageModes && sc.PageModes.ChromeManager);\n  }\n  static resetChromes() {\n    if ((0, is_server_1.default)()) {\n      return;\n    }\n    window.Sitecore.PageModes.ChromeManager.resetChromes();\n  }\n}\nexports.ExperienceEditor = ExperienceEditor;\n/**\n * Copy of chrome rediscovery contract from Horizon (chrome-rediscovery.contract.ts)\n */\nexports.ChromeRediscoveryGlobalFunctionName = {\n  name: 'Sitecore.Horizon.ResetChromes'\n};\n/**\n * Static utility class for Sitecore Pages Editor (ex-Horizon)\n */\nclass HorizonEditor {\n  /**\n   * Determines whether the current execution context is within a Pages Editor.\n   * Pages Editor environment can be identified only in the browser\n   * @returns true if executing within a Pages Editor\n   */\n  static isActive() {\n    if ((0, is_server_1.default)()) {\n      return false;\n    }\n    // Check for Chromes mode\n    const chromesCheck = window.location.search.indexOf('sc_headless_mode=edit') > -1;\n    // JSS will render a jss-exclusive script element in Metadata mode to indicate edit mode in Pages\n    return chromesCheck || !!window.document.getElementById(exports.PAGES_EDITING_MARKER);\n  }\n  static resetChromes() {\n    if ((0, is_server_1.default)()) {\n      return;\n    }\n    // Reset chromes in Pages\n    window[exports.ChromeRediscoveryGlobalFunctionName.name] && window[exports.ChromeRediscoveryGlobalFunctionName.name]();\n  }\n}\nexports.HorizonEditor = HorizonEditor;\n/**\n * Determines whether the current execution context is within a Sitecore editor.\n * Sitecore Editor environment can be identified only in the browser\n * @returns true if executing within a Sitecore editor\n */\nconst isEditorActive = () => {\n  return ExperienceEditor.isActive() || HorizonEditor.isActive();\n};\nexports.isEditorActive = isEditorActive;\n/**\n * Resets Sitecore editor \"chromes\"\n */\nconst resetEditorChromes = () => {\n  if (ExperienceEditor.isActive()) {\n    ExperienceEditor.resetChromes();\n  } else if (HorizonEditor.isActive()) {\n    HorizonEditor.resetChromes();\n  }\n};\nexports.resetEditorChromes = resetEditorChromes;\n/**\n * @description in Experience Editor, anchor tags\n * with both onclick and href attributes will use the href, blocking the onclick from firing.\n * This function makes it so the anchor tags function as intended in the sample when using Experience Editor\n *\n * The Mutation Observer API is used to observe changes to the body, then select all elements with href=\"#\" and an onclick,\n * and replaces the # value with javascript:void(0); which prevents the anchor tag from blocking the onclick event handler.\n * @see Mutation Observer API: https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/MutationObserver\n */\nconst handleEditorAnchors = () => {\n  // The sample gives the href attribute priority over the onclick attribute if both are present, so we must replace\n  // the href attribute to avoid overriding the onclick in Experience Editor\n  if (!window || !ExperienceEditor.isActive()) {\n    return;\n  }\n  const targetNode = document.querySelector('body');\n  const callback = mutationList => {\n    mutationList.forEach(mutation => {\n      const btns = document.querySelectorAll('.scChromeDropDown > a[href=\"#\"], .scChromeDropDown > a[href=\"#!\"], a[onclick]');\n      if (mutation.type === 'childList') {\n        btns.forEach(link => {\n          link.href = 'javascript:void(0);';\n        });\n      }\n      return;\n    });\n  };\n  const observer = new MutationObserver(callback);\n  const observerOptions = {\n    childList: true,\n    subtree: true\n  };\n  if (targetNode) {\n    observer.observe(targetNode, observerOptions);\n  }\n};\nexports.handleEditorAnchors = handleEditorAnchors;\n/**\n * Gets extra JSS clientData scripts to render in XMC Pages in addition to clientData from Pages itself\n * @returns {Record} collection of clientData\n */\nconst getJssPagesClientData = () => {\n  const clientData = {};\n  clientData[exports.PAGES_EDITING_MARKER] = {};\n  return clientData;\n};\nexports.getJssPagesClientData = getJssPagesClientData;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}