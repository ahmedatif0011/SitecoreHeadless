{"ast":null,"code":"import { PLATFORM_ID } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { EMPTY } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { isEditorActive, resetEditorChromes } from '@sitecore-jss/sitecore-jss-angular';\nimport { JssContextService } from './jss-context.service';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"apollo-angular\";\nimport * as i2 from \"./jss-context.service\";\n/**\n * Provides GraphQL querying services via Apollo Client.\n * This service is needed to use _connected GraphQL_ with your JSS app.\n * If you are not using GraphQL, or are only using the _integrated GraphQL_\n * that is within the Layout Service, you do not need this service.\n *\n * Compared to using apollo-angular directly, using this service:\n * * Handles Sitecore SSR issues\n * * Makes available ambient $datasource and $contextItem GQL variables based on current route data\n * * Integrates with Sitecore Experience Editor's DOM-based update needs\n *\n * The API is identical to apollo-angular's `Apollo` service otherwise.\n */\nexport let JssGraphQLService = /*#__PURE__*/(() => {\n  class JssGraphQLService {\n    apollo;\n    sitecoreContext;\n    platformId;\n    isEditingOrPreviewingAndSsr;\n    constructor(apollo, sitecoreContext, platformId) {\n      this.apollo = apollo;\n      this.sitecoreContext = sitecoreContext;\n      this.platformId = platformId;\n      this.isEditingOrPreviewingAndSsr = isPlatformServer(this.platformId) && this.sitecoreContext.stateValue.sitecore.context.pageState !== 'normal';\n    }\n    static extractVariableNames(query) {\n      const variableNames = {};\n      query.definitions.map(def => def.variableDefinitions).filter(def => def).forEach(defs => defs.forEach(def => {\n        if (def.kind && def.kind === 'VariableDefinition') {\n          variableNames[def.variable.name.value] = true;\n        }\n      }));\n      return variableNames;\n    }\n    /**\n     * Executes a read query against the GraphQL endpoint\n     */\n    query(options) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return EMPTY;\n      }\n      options.variables = this.addJssAmbientVariables(options.query, options.variables, options.renderingContext);\n      const observable = this.apollo.query(options);\n      // When a query reply is received, and we're in Experience Editor mode,\n      // xEditor needs to know to rebind to the editable DOM elements after they get inserted\n      // (assuming use of `jss` field in the GQL query). This accomplishes that.\n      observable.pipe(first()).subscribe(() => {\n        setTimeout(() => {\n          if (isEditorActive()) {\n            resetEditorChromes();\n          }\n        }, 1000);\n      });\n      return observable;\n    }\n    /**\n     * Executes a GraphQL mutation (write) against the GraphQL endpoint\n     */\n    mutate(options) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return EMPTY;\n      }\n      this.addJssAmbientVariables(options.mutation, options.variables, options.renderingContext);\n      return this.apollo.mutate(options);\n    }\n    /**\n     * Executes a GraphQL subscription (real-time data) against the GraphQL endpoint\n     */\n    subscribe(options, extra) {\n      if (this.isEditingOrPreviewingAndSsr) {\n        return EMPTY;\n      }\n      this.addJssAmbientVariables(options.query, options.variables, options.renderingContext);\n      return this.apollo.subscribe(options, extra);\n    }\n    addJssAmbientVariables(query, variables, rendering) {\n      if (!variables) {\n        variables = {};\n      }\n      const usedVariables = JssGraphQLService.extractVariableNames(query);\n      if (usedVariables.datasource && rendering && rendering.dataSource) {\n        variables.datasource = rendering.dataSource;\n      }\n      if (usedVariables.contextItem && this.sitecoreContext.stateValue.sitecore && this.sitecoreContext.stateValue.sitecore.route && this.sitecoreContext.stateValue.sitecore.route.itemId) {\n        variables.contextItem = this.sitecoreContext.stateValue.sitecore.route.itemId;\n      }\n      // pass language as a variable to the query, if language exists as a variable and in sitecoreContext\n      if (usedVariables.language && this.sitecoreContext.stateValue.language) {\n        variables.language = this.sitecoreContext.stateValue.language;\n      }\n      return variables;\n    }\n    static ɵfac = function JssGraphQLService_Factory(t) {\n      return new (t || JssGraphQLService)(i0.ɵɵinject(i1.Apollo), i0.ɵɵinject(i2.JssContextService), i0.ɵɵinject(PLATFORM_ID));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: JssGraphQLService,\n      factory: JssGraphQLService.ɵfac\n    });\n  }\n  return JssGraphQLService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}