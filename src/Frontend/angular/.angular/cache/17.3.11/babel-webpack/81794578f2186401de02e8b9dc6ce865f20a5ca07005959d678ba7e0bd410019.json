{"ast":null,"code":"\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\nfunction evenRound(x) {\n  // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n  if (x % 1 === 0.5 && (x & 1) === 0) {\n    // [even number].5; round down (i.e. floor)\n    return Math.floor(x);\n  } else {\n    return Math.round(x);\n  }\n}\nfunction createNumberConversion(bitLength, typeOpts) {\n  if (!typeOpts.unsigned) {\n    --bitLength;\n  }\n  const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n  const upperBound = Math.pow(2, bitLength) - 1;\n  const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n  const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n  return function (V, opts) {\n    if (!opts) opts = {};\n    let x = +V;\n    if (opts.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite number\");\n      }\n      x = sign(x) * Math.floor(Math.abs(x));\n      if (x < lowerBound || x > upperBound) {\n        throw new TypeError(\"Argument is not in byte range\");\n      }\n      return x;\n    }\n    if (!isNaN(x) && opts.clamp) {\n      x = evenRound(x);\n      if (x < lowerBound) x = lowerBound;\n      if (x > upperBound) x = upperBound;\n      return x;\n    }\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n    x = sign(x) * Math.floor(Math.abs(x));\n    x = x % moduloVal;\n    if (!typeOpts.unsigned && x >= moduloBound) {\n      return x - moduloVal;\n    } else if (typeOpts.unsigned) {\n      if (x < 0) {\n        x += moduloVal;\n      } else if (x === -0) {\n        // don't return negative zero\n        return 0;\n      }\n    }\n    return x;\n  };\n}\nconversions[\"void\"] = function () {\n  return undefined;\n};\nconversions[\"boolean\"] = function (val) {\n  return !!val;\n};\nconversions[\"byte\"] = createNumberConversion(8, {\n  unsigned: false\n});\nconversions[\"octet\"] = createNumberConversion(8, {\n  unsigned: true\n});\nconversions[\"short\"] = createNumberConversion(16, {\n  unsigned: false\n});\nconversions[\"unsigned short\"] = createNumberConversion(16, {\n  unsigned: true\n});\nconversions[\"long\"] = createNumberConversion(32, {\n  unsigned: false\n});\nconversions[\"unsigned long\"] = createNumberConversion(32, {\n  unsigned: true\n});\nconversions[\"long long\"] = createNumberConversion(32, {\n  unsigned: false,\n  moduloBitLength: 64\n});\nconversions[\"unsigned long long\"] = createNumberConversion(32, {\n  unsigned: true,\n  moduloBitLength: 64\n});\nconversions[\"double\"] = function (V) {\n  const x = +V;\n  if (!Number.isFinite(x)) {\n    throw new TypeError(\"Argument is not a finite floating-point value\");\n  }\n  return x;\n};\nconversions[\"unrestricted double\"] = function (V) {\n  const x = +V;\n  if (isNaN(x)) {\n    throw new TypeError(\"Argument is NaN\");\n  }\n  return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\nconversions[\"DOMString\"] = function (V, opts) {\n  if (!opts) opts = {};\n  if (opts.treatNullAsEmptyString && V === null) {\n    return \"\";\n  }\n  return String(V);\n};\nconversions[\"ByteString\"] = function (V, opts) {\n  const x = String(V);\n  let c = undefined;\n  for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n    if (c > 255) {\n      throw new TypeError(\"Argument is not a valid bytestring\");\n    }\n  }\n  return x;\n};\nconversions[\"USVString\"] = function (V) {\n  const S = String(V);\n  const n = S.length;\n  const U = [];\n  for (let i = 0; i < n; ++i) {\n    const c = S.charCodeAt(i);\n    if (c < 0xD800 || c > 0xDFFF) {\n      U.push(String.fromCodePoint(c));\n    } else if (0xDC00 <= c && c <= 0xDFFF) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else {\n      if (i === n - 1) {\n        U.push(String.fromCodePoint(0xFFFD));\n      } else {\n        const d = S.charCodeAt(i + 1);\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          const a = c & 0x3FF;\n          const b = d & 0x3FF;\n          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n          ++i;\n        } else {\n          U.push(String.fromCodePoint(0xFFFD));\n        }\n      }\n    }\n  }\n  return U.join('');\n};\nconversions[\"Date\"] = function (V, opts) {\n  if (!(V instanceof Date)) {\n    throw new TypeError(\"Argument is not a Date object\");\n  }\n  if (isNaN(V)) {\n    return undefined;\n  }\n  return V;\n};\nconversions[\"RegExp\"] = function (V, opts) {\n  if (!(V instanceof RegExp)) {\n    V = new RegExp(V);\n  }\n  return V;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}