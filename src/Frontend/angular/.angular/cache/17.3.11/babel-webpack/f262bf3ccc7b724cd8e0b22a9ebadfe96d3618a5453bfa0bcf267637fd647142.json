{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JssContextService = exports.jssKey = void 0;\nconst tslib_1 = require(\"tslib\");\nconst core_1 = require(\"@angular/core\");\nconst sitecore_jss_angular_1 = require(\"@sitecore-jss/sitecore-jss-angular\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst jss_layout_service_1 = require(\"./layout/jss-layout.service\");\nconst JssState_1 = require(\"./JssState\");\nconst i0 = tslib_1.__importStar(require(\"@angular/core\"));\nconst i1 = tslib_1.__importStar(require(\"./layout/jss-layout.service\"));\nconst i2 = tslib_1.__importStar(require(\"@sitecore-jss/sitecore-jss-angular\"));\nexports.jssKey = (0, core_1.makeStateKey)('jss');\n/**\n * Stores the JSS app's context (current route and Sitecore context data).\n * This implementation runs on the client (browser) side; see jss-context.server-side.service.ts\n * for the implementation that runs on the server (SSR) side.\n */\nlet JssContextService = /*#__PURE__*/(() => {\n  class JssContextService {\n    transferState;\n    layoutService;\n    stateService;\n    // components can subscribe to this (or use getValue()) to get access to latest data from Layout Service,\n    // as well as current language and server route\n    get state() {\n      return this.stateService.state;\n    }\n    get stateValue() {\n      return this.stateService.stateValue;\n    }\n    constructor(transferState, layoutService, stateService) {\n      this.transferState = transferState;\n      this.layoutService = layoutService;\n      this.stateService = stateService;\n    }\n    changeLanguage(language) {\n      this.stateService.setState({\n        ...this.stateService.stateValue,\n        language\n      });\n    }\n    // primarily invoked by JssRouteResolver on URL/route change\n    changeRoute(route, language) {\n      // on client initial load, retrieve initial state from server\n      const foundInitialState = this.transferState.hasKey(exports.jssKey);\n      if (foundInitialState) {\n        const jssState = this.transferState.get(exports.jssKey, null);\n        this.transferState.remove(exports.jssKey);\n        this.stateService.setState(jssState);\n        return (0, rxjs_1.of)(jssState);\n      }\n      const appLanguage = this.stateService.stateValue.language || language;\n      const jssState$ = this.layoutService.getRouteData(route, appLanguage).pipe((0, operators_1.map)(routeData => {\n        const lsResult = routeData;\n        const result = new JssState_1.JssState();\n        result.sitecore = lsResult.sitecore ? lsResult.sitecore : null;\n        result.language = appLanguage;\n        result.serverRoute = route;\n        return result;\n      }), (0, operators_1.catchError)(error => {\n        const result = new JssState_1.JssState();\n        result.language = appLanguage;\n        result.serverRoute = route;\n        result.routeFetchError = error;\n        return (0, rxjs_1.of)(result);\n      }), (0, operators_1.shareReplay)(1));\n      // subscribe to it ourselves so we can maintain current state\n      jssState$.subscribe(jssState => {\n        this.stateService.setState(jssState);\n      });\n      return jssState$;\n    }\n    static ɵfac = function JssContextService_Factory(t) {\n      return new (t || JssContextService)(i0.ɵɵinject(i0.TransferState), i0.ɵɵinject(i1.JssLayoutService), i0.ɵɵinject(i2.JssStateService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: JssContextService,\n      factory: JssContextService.ɵfac\n    });\n  }\n  return JssContextService;\n})();\nexports.JssContextService = JssContextService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}