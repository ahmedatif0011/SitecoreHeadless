{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setUpDefaultAgents = exports.parseRouteUrl = exports.renderView = void 0;\nconst tslib_1 = require(\"tslib\");\n// These are important and needed before anything else\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nrequire(\"reflect-metadata\");\nrequire(\"zone.js\");\nconst jss_route_builder_service_1 = require(\"./src/app/routing/jss-route-builder.service\");\nconst main_server_1 = require(\"./src/main.server\");\ntslib_1.__exportStar(require(\"./src/main.server\"), exports);\ntslib_1.__exportStar(require(\"./server.exports\"), exports);\nconst http = require('http');\nconst https = require('https');\n// Our index.html we'll use as our template\nconst template = (0, fs_1.readFileSync)((0, path_1.join)(__dirname, 'browser', 'index.html')).toString();\n// Setup Http/Https agents for keep-alive. Used in headless-proxy\nconst setUpDefaultAgents = (httpAgent, httpsAgent) => {\n  http.globalAgent = httpAgent;\n  https.globalAgent = httpsAgent;\n};\nexports.setUpDefaultAgents = setUpDefaultAgents;\n// this is the function expected by the JSS View Engine for \"integrated mode\"\nfunction renderView(callback, path, data, viewBag) {\n  try {\n    /*\n      Data from server is double-encoded since MS JSS does not allow control\n      over JSON serialization format.\n    */\n    const parsedData = data instanceof Object ? data : JSON.parse(data);\n    const parsedViewBag = viewBag instanceof Object ? viewBag : JSON.parse(viewBag);\n    const state = {\n      sitecore: {\n        context: {\n          pageEditing: false\n        },\n        route: {\n          placeholders: {}\n        }\n      },\n      language: '',\n      serverRoute: '',\n      viewBag: parsedViewBag\n    };\n    if (parsedData) {\n      state.sitecore = parsedData.sitecore;\n      state.language = parsedData.sitecore.context.language;\n    }\n    // parse the URL that's being handled by Sitecore so we can pass in the initial state to the app\n    const routeParser = new jss_route_builder_service_1.JssRouteBuilderService();\n    const jssRoute = routeParser.parseRouteUrl(path.split('/').filter(segment => segment));\n    state.serverRoute = jssRoute.serverRoute;\n    if (!state.language) {\n      state.language = jssRoute.language;\n    }\n    const transferState = {\n      ...state\n    };\n    delete transferState.viewBag;\n    (0, main_server_1.renderModule)(main_server_1.AppServerModule, {\n      document: template,\n      url: path,\n      extraProviders: [\n      // custom injection with the initial state that SSR should utilize\n      {\n        provide: 'JSS_SERVER_LAYOUT_DATA',\n        useValue: transferState\n      }, {\n        provide: 'JSS_SERVER_VIEWBAG',\n        useValue: state.viewBag\n      }]\n    }).then(html => callback(null, {\n      html\n    })).catch(err => callback(err, null));\n  } catch (err) {\n    // need to ensure the callback is always invoked no matter what\n    // or else SSR will hang\n    callback(err, null);\n  }\n}\nexports.renderView = renderView;\nfunction parseRouteUrl(url) {\n  const routeParser = new jss_route_builder_service_1.JssRouteBuilderService();\n  const jssRoute = routeParser.parseRouteUrl(url.split('/').filter(segment => segment), true);\n  return {\n    lang: jssRoute.language,\n    sitecoreRoute: jssRoute.serverRoute\n  };\n}\nexports.parseRouteUrl = parseRouteUrl;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}