{"ast":null,"code":"import { TransferState, makeStateKey } from '@angular/core';\nimport { JssStateService } from '@sitecore-jss/sitecore-jss-angular';\nimport { map, shareReplay, catchError } from 'rxjs/operators';\nimport { of as observableOf } from 'rxjs';\nimport { JssLayoutService } from './layout/jss-layout.service';\nimport { JssState } from './JssState';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./layout/jss-layout.service\";\nimport * as i2 from \"@sitecore-jss/sitecore-jss-angular\";\nexport const jssKey = makeStateKey('jss');\n/**\n * Stores the JSS app's context (current route and Sitecore context data).\n * This implementation runs on the client (browser) side; see jss-context.server-side.service.ts\n * for the implementation that runs on the server (SSR) side.\n */\nexport let JssContextService = /*#__PURE__*/(() => {\n  class JssContextService {\n    transferState;\n    layoutService;\n    stateService;\n    // components can subscribe to this (or use getValue()) to get access to latest data from Layout Service,\n    // as well as current language and server route\n    get state() {\n      return this.stateService.state;\n    }\n    get stateValue() {\n      return this.stateService.stateValue;\n    }\n    constructor(transferState, layoutService, stateService) {\n      this.transferState = transferState;\n      this.layoutService = layoutService;\n      this.stateService = stateService;\n    }\n    changeLanguage(language) {\n      this.stateService.setState({\n        ...this.stateService.stateValue,\n        language\n      });\n    }\n    // primarily invoked by JssRouteResolver on URL/route change\n    changeRoute(route, language) {\n      // on client initial load, retrieve initial state from server\n      const foundInitialState = this.transferState.hasKey(jssKey);\n      if (foundInitialState) {\n        const jssState = this.transferState.get(jssKey, null);\n        this.transferState.remove(jssKey);\n        this.stateService.setState(jssState);\n        return observableOf(jssState);\n      }\n      const appLanguage = this.stateService.stateValue.language || language;\n      const jssState$ = this.layoutService.getRouteData(route, appLanguage).pipe(map(routeData => {\n        const lsResult = routeData;\n        const result = new JssState();\n        result.sitecore = lsResult.sitecore ? lsResult.sitecore : null;\n        result.language = appLanguage;\n        result.serverRoute = route;\n        return result;\n      }), catchError(error => {\n        const result = new JssState();\n        result.language = appLanguage;\n        result.serverRoute = route;\n        result.routeFetchError = error;\n        return observableOf(result);\n      }), shareReplay(1));\n      // subscribe to it ourselves so we can maintain current state\n      jssState$.subscribe(jssState => {\n        this.stateService.setState(jssState);\n      });\n      return jssState$;\n    }\n    static ɵfac = function JssContextService_Factory(t) {\n      return new (t || JssContextService)(i0.ɵɵinject(i0.TransferState), i0.ɵɵinject(i1.JssLayoutService), i0.ɵɵinject(i2.JssStateService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: JssContextService,\n      factory: JssContextService.ɵfac\n    });\n  }\n  return JssContextService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}