{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSrcSet = exports.updateImageUrl = exports.replaceMediaUrlPrefix = exports.getRequiredParams = exports.findEditorImageTag = void 0;\nconst lodash_unescape_1 = __importDefault(require(\"lodash.unescape\"));\nconst url_parse_1 = __importDefault(require(\"url-parse\"));\n// finds an img tag with HTML attributes\nconst imgTagRegex = /<img([^>]+)\\/>/i;\n// finds all the HTML attributes in a string\nconst htmlAttrsRegex = /([^=\\s]+)(=\"([^\"]*)\")?/gi;\n// finds the Sitecore media URL prefix\nconst mediaUrlPrefixRegex = /\\/([-~]{1})\\/media\\//i;\n/**\n * Makes a request to Sitecore Content Service for the specified item path.\n * @param {string} editorMarkup the markup to parse\n * @returns {object | null} found image tag; null in case if not found\n */\nconst findEditorImageTag = editorMarkup => {\n  // match the tag\n  const tagMatch = editorMarkup.match(imgTagRegex);\n  if (!tagMatch || tagMatch.length < 2) {\n    return null;\n  }\n  // find the attrs and turn them into a Map\n  const attrs = {};\n  let match = htmlAttrsRegex.exec(tagMatch[1]);\n  while (match !== null) {\n    attrs[match[1]] = (0, lodash_unescape_1.default)(match[3]);\n    match = htmlAttrsRegex.exec(tagMatch[1]);\n  }\n  return {\n    imgTag: tagMatch[0],\n    attrs\n  };\n};\nexports.findEditorImageTag = findEditorImageTag;\n/**\n * Get required query string params which should be merged with user params\n * @param {object} qs layout service parsed query string\n * @returns {object} requiredParams\n */\nconst getRequiredParams = qs => {\n  const {\n    rev,\n    db,\n    la,\n    vs,\n    ts\n  } = qs;\n  return {\n    rev,\n    db,\n    la,\n    vs,\n    ts\n  };\n};\nexports.getRequiredParams = getRequiredParams;\n/**\n * Replace `/~/media` or `/-/media` with `/~/jssmedia` or `/-/jssmedia`, respectively.\n * Can use `mediaUrlPrefix` in order to use a custom prefix.\n * @param {string} url The URL to replace the media URL prefix in\n * @param {RegExp} [mediaUrlPrefix] The regex to match the media URL prefix\n * @returns {string} The URL with the media URL prefix replaced\n */\nconst replaceMediaUrlPrefix = (url, mediaUrlPrefix = mediaUrlPrefixRegex) => {\n  const parsed = (0, url_parse_1.default)(url, {}, true);\n  const match = mediaUrlPrefix.exec(parsed.pathname);\n  if (match && match.length > 1) {\n    // regex will provide us with /-/ or /~/ type\n    parsed.set('pathname', parsed.pathname.replace(mediaUrlPrefix, `/${match[1]}/jssmedia/`));\n  }\n  return parsed.toString();\n};\nexports.replaceMediaUrlPrefix = replaceMediaUrlPrefix;\n/**\n * Prepares a Sitecore media URL with `params` for use by the JSS media handler.\n * This is done by replacing `/~/media` or `/-/media` with `/~/jssmedia` or `/-/jssmedia`, respectively.\n * Provided `params` are used as the querystring parameters for the media URL.\n * Can use `mediaUrlPrefix` in order to use a custom prefix.\n * If no `params` are sent, the original media URL is returned.\n * @param {string} url The URL to prepare\n * @param {object} [params] The querystring parameters to use\n * @param {RegExp} [mediaUrlPrefix] The regex to match the media URL prefix\n * @returns {string} The prepared URL\n */\nconst updateImageUrl = (url, params, mediaUrlPrefix = mediaUrlPrefixRegex) => {\n  if (!params || Object.keys(params).length === 0) {\n    // if params aren't supplied, no need to run it through JSS media handler\n    return url;\n  }\n  // polyfill node `global` in browser to workaround https://github.com/unshiftio/url-parse/issues/150\n  if (typeof window !== 'undefined' && !window.global) {\n    window.global = {};\n  }\n  const parsed = (0, url_parse_1.default)((0, exports.replaceMediaUrlPrefix)(url, mediaUrlPrefix), {}, true);\n  const requiredParams = (0, exports.getRequiredParams)(parsed.query);\n  const query = Object.assign({}, params);\n  Object.entries(requiredParams).forEach(([key, param]) => {\n    if (param) {\n      query[key] = param;\n    }\n  });\n  parsed.set('query', query);\n  return parsed.toString();\n};\nexports.updateImageUrl = updateImageUrl;\n/**\n * Receives an array of `srcSet` parameters that are iterated and used as parameters to generate\n * a corresponding set of updated Sitecore media URLs via @see updateImageUrl. The result is a comma-delimited\n * list of media URLs with respective dimension parameters.\n * @example\n * // returns '/ipsum.jpg?h=1000&w=1000 1000w, /ipsum.jpg?mh=250&mw=250 250w'\n * getSrcSet('/ipsum.jpg', [{ h: 1000, w: 1000 }, { mh: 250, mw: 250 } ])\n * More information about `srcSet`: {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n * @param {string} url The URL to prepare\n * @param {Array} srcSet The array of parameters to use\n * @param {object} [imageParams] The querystring parameters to use\n * @param {RegExp} [mediaUrlPrefix] The regex to match the media URL prefix\n * @returns {string} The prepared URL\n */\nconst getSrcSet = (url, srcSet, imageParams, mediaUrlPrefix) => {\n  return srcSet.map(params => {\n    const newParams = Object.assign(Object.assign({}, imageParams), params);\n    const imageWidth = newParams.w || newParams.mw;\n    if (!imageWidth) {\n      return null;\n    }\n    return `${(0, exports.updateImageUrl)(url, newParams, mediaUrlPrefix)} ${imageWidth}w`;\n  }).filter(value => value).join(', ');\n};\nexports.getSrcSet = getSrcSet;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}