{"ast":null,"code":"import isServer from './is-server';\n/**\n * note: encodeURIComponent is available via browser (window) or natively in node.js\n * if you use another js engine for server-side rendering you may not have native encodeURIComponent\n * and would then need to install a package for that functionality\n * @param {ParsedUrlQueryInput} params query string parameters\n * @returns {string} query string\n */\nfunction getQueryString(params) {\n  return Object.keys(params).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(String(params[k]))}`).join('&');\n}\n/**\n * Resolves a base URL that may contain query string parameters and an additional set of query\n * string parameters into a unified string representation.\n * @param {string} urlBase the base URL that may contain query string parameters\n * @param {ParsedUrlQueryInput} params query string parameters\n * @returns a URL string\n * @throws {RangeError} if the provided url is an empty string\n */\nexport function resolveUrl(urlBase, params = {}) {\n  if (!urlBase) {\n    throw new RangeError('url must be a non-empty string');\n  }\n  // This is a better way to work with URLs since it handles different user input\n  // edge cases. This works in Node and all browser except IE11.\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL\n  // TODO: Verify our browser support requirements.\n  if (isServer()) {\n    const url = new URL(urlBase);\n    for (const key in params) {\n      if ({}.hasOwnProperty.call(params, key)) {\n        url.searchParams.append(key, String(params[key]));\n      }\n    }\n    const result = url.toString();\n    return result;\n  }\n  const qs = getQueryString(params);\n  const result = urlBase.indexOf('?') !== -1 ? `${urlBase}&${qs}` : `${urlBase}?${qs}`;\n  return result;\n}\nexport const isAbsoluteUrl = url => {\n  if (!url) {\n    return false;\n  }\n  if (typeof url !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return /^[a-z][a-z0-9+.-]*:/.test(url);\n};\n/**\n * Indicates whether the error is a timeout error\n * @param {unknown} error error\n * @returns {boolean} is timeout error\n */\nexport const isTimeoutError = error => {\n  var _a;\n  return error.code === '408' || error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT' || ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 408 || error.name === 'AbortError';\n};\n/**\n * Converts a string value in a regex pattern allowing wildcard matching\n * @param {string} pattern input with wildcards i.e. site.*.com\n * @returns {string} modified string that can be used as regexp input\n */\nconst convertToWildcardRegex = pattern => {\n  return '^' + pattern.replace(/\\//g, '\\\\/').replace(/\\./g, '\\\\.').replace(/\\*/g, '.*') + '$';\n};\n/**\n * Gets allowed origins from JSS_ALLOWED_ORIGINS env variable\n * @returns {string[]} list of allowed origins from JSS_ALLOWED_ORIGINS env variable\n */\nexport const getAllowedOriginsFromEnv = () => process.env.JSS_ALLOWED_ORIGINS ? process.env.JSS_ALLOWED_ORIGINS.replace(' ', '').split(',') : [];\n/**\n * Tests origin from incoming request against allowed origins list that can be\n * set in JSS's JSS_ALLOWED_ORIGINS env variable, passed via allowedOrigins param and/or\n * be already set in Access-Control-Allow-Origin by other logic.\n * Applies Access-Control-Allow-Origin and Access-Control-Allow-Methods on match\n * Also applies Access-Control-Allow-Headers for preflight requests\n * @param {IncomingMessage} req incoming request\n * @param {OutgoingMessage} res response to set CORS headers for\n * @param {string[]} [allowedOrigins] additional list of origins to test against\n * @returns true if incoming origin matches the allowed lists, false when it does not\n */\nexport const enforceCors = (req, res, allowedOrigins) => {\n  // origin in not present for non-CORS requests (e.g. server-side) - so we skip the checks\n  if (!req.headers.origin) {\n    return true;\n  }\n  // 3 sources of allowed origins are considered:\n  // the env value\n  const defaultAllowedOrigins = getAllowedOriginsFromEnv();\n  // the allowedOrigins prop\n  allowedOrigins = defaultAllowedOrigins.concat(allowedOrigins || []);\n  // and the existing CORS header, if present (i.e. set by nextjs config)\n  const presetCors = res.getHeader('Access-Control-Allow-Origin');\n  if (presetCors) {\n    allowedOrigins.push(presetCors);\n  }\n  const origin = req.headers.origin;\n  if (origin && allowedOrigins.some(allowedOrigin => origin === allowedOrigin || new RegExp(convertToWildcardRegex(allowedOrigin)).test(origin))) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, DELETE, PUT, PATCH');\n    // set the allowed headers for preflight requests\n    if (req.method === 'OPTIONS') {\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    }\n    return true;\n  }\n  return false;\n};\n/**\n * Generates all possible permutations of an array of key-value pairs.\n * This is used to create every possible combination of URL query parameters.\n * @param {Array<[string, string]>} array - The array of key-value pairs to permute.\n * @returns {Array<Array<[string, string]>>} - A 2D array where each inner array is a unique permutation of the input.\n */\nexport const getPermutations = array => {\n  if (array.length <= 1) return [array];\n  return array.flatMap((current, i) => {\n    const remaining = array.filter((_, idx) => idx !== i);\n    return getPermutations(remaining).map(permutation => [current, ...permutation]);\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}