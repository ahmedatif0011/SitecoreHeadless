{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLDictionaryService = exports.queryError = void 0;\nconst constants_1 = require(\"../constants\");\nconst dictionary_service_1 = require(\"./dictionary-service\");\nconst graphql_1 = require(\"../graphql\");\nconst app_root_query_1 = require(\"../graphql/app-root-query\");\nconst debug_1 = __importDefault(require(\"../debug\"));\n/** @private */\nexports.queryError = 'Valid value for rootItemId not provided and failed to auto-resolve app root item.';\n/** @default */\nconst query = /* GraphQL */`\n  query DictionarySearch(\n    $rootItemId: String!\n    $language: String!\n    $templates: String!\n    $pageSize: Int = 10\n    $after: String\n  ) {\n    search(\n      where: {\n        AND: [\n          { name: \"_path\", value: $rootItemId, operator: CONTAINS }\n          { name: \"_language\", value: $language }\n          { name: \"_templates\", value: $templates, operator: CONTAINS }\n        ]\n      }\n      first: $pageSize\n      after: $after\n    ) {\n      total\n      pageInfo {\n        endCursor\n        hasNext\n      }\n      results {\n        key: field(name: \"Key\") {\n          value\n        }\n        phrase: field(name: \"Phrase\") {\n          value\n        }\n      }\n    }\n  }\n`;\nconst siteQuery = /* GraphQL */`\n  query DictionarySiteQuery(\n    $siteName: String!\n    $language: String!\n    $pageSize: Int = 500\n    $after: String\n  ) {\n    site {\n      siteInfo(site: $siteName) {\n        dictionary(language: $language, first: $pageSize, after: $after) {\n          pageInfo {\n            endCursor\n            hasNext\n          }\n          results {\n            key\n            value\n          }\n        }\n      }\n    }\n  }\n`;\n/**\n * Service that fetch dictionary data using Sitecore's GraphQL API.\n * @augments DictionaryServiceBase\n * @mixes SearchQueryService<DictionaryQueryResult>\n */\nclass GraphQLDictionaryService extends dictionary_service_1.DictionaryServiceBase {\n  /**\n   * Creates an instance of graphQL dictionary service with the provided options\n   * @param {GraphQLDictionaryService} options instance\n   */\n  constructor(options) {\n    super(options);\n    this.options = options;\n    this.graphQLClient = this.getGraphQLClient();\n    this.searchService = new graphql_1.SearchQueryService(this.graphQLClient);\n  }\n  /**\n   * Fetches dictionary data for internalization. Uses search query by default\n   * @param {string} language the language to fetch\n   * @returns {Promise<DictionaryPhrases>} dictionary phrases\n   * @throws {Error} if the app root was not found for the specified site and language.\n   */\n  fetchDictionaryData(language) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cacheKey = this.options.siteName + language;\n      const cachedValue = this.getCacheValue(cacheKey);\n      if (cachedValue) {\n        debug_1.default.dictionary('using cached dictionary data for %s %s', language, this.options.siteName);\n        return cachedValue;\n      }\n      const phrases = this.options.useSiteQuery ? yield this.fetchWithSiteQuery(language) : yield this.fetchWithSearchQuery(language);\n      this.setCacheValue(cacheKey, phrases);\n      return phrases;\n    });\n  }\n  /**\n   * Fetches dictionary data with search query\n   * This is the default behavior for non-XMCloud deployments. Uses `query` to retrieve data.\n   * @param {string} language the language to fetch\n   * @returns {Promise<DictionaryPhrases>} dictionary phrases\n   * @throws {Error} if the app root was not found for the specified site and language.\n   */\n  fetchWithSearchQuery(language) {\n    return __awaiter(this, void 0, void 0, function* () {\n      debug_1.default.dictionary('fetching site root for %s %s', language, this.options.siteName);\n      // If the caller does not specify a root item ID, then we try to figure it out\n      const rootItemId = this.options.rootItemId || (yield (0, graphql_1.getAppRootId)(this.graphQLClient, this.options.siteName, language, this.options.jssAppTemplateId));\n      if (!rootItemId) {\n        throw new Error(exports.queryError);\n      }\n      debug_1.default.dictionary('fetching dictionary data for %s %s', language, this.options.siteName);\n      const phrases = {};\n      yield this.searchService.fetch(query, {\n        rootItemId,\n        language,\n        templates: this.options.dictionaryEntryTemplateId || constants_1.SitecoreTemplateId.DictionaryEntry,\n        pageSize: this.options.pageSize\n      }).then(results => {\n        results.forEach(item => phrases[item.key.value] = item.phrase.value);\n      });\n      return phrases;\n    });\n  }\n  /**\n   * Fetches dictionary data with site query\n   * This is the default behavior for XMCloud deployments. Uses `siteQuery` to retrieve data.\n   * @param {string} language the language to fetch\n   * @returns {Promise<DictionaryPhrases>} dictionary phrases\n   */\n  fetchWithSiteQuery(language) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const phrases = {};\n      debug_1.default.dictionary('fetching dictionary data for %s %s', language, this.options.siteName);\n      let results = [];\n      let hasNext = true;\n      let after = '';\n      if (!this.options.siteName) {\n        throw new RangeError(app_root_query_1.siteNameError);\n      }\n      if (!language) {\n        throw new RangeError(app_root_query_1.languageError);\n      }\n      while (hasNext) {\n        const fetchResponse = yield this.graphQLClient.request(siteQuery, {\n          siteName: this.options.siteName,\n          language,\n          pageSize: this.options.pageSize,\n          after\n        });\n        if ((_b = (_a = fetchResponse === null || fetchResponse === void 0 ? void 0 : fetchResponse.site) === null || _a === void 0 ? void 0 : _a.siteInfo) === null || _b === void 0 ? void 0 : _b.dictionary) {\n          results = results.concat(fetchResponse.site.siteInfo.dictionary.results);\n          after = fetchResponse.site.siteInfo.dictionary.pageInfo.endCursor;\n          hasNext = fetchResponse.site.siteInfo.dictionary.pageInfo.hasNext;\n        } else {\n          hasNext = false;\n        }\n      }\n      results.forEach(item => phrases[item.key] = item.value);\n      return phrases;\n    });\n  }\n  /**\n   * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default\n   * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you\n   * want to use something else.\n   * @returns {GraphQLClient} implementation\n   */\n  getGraphQLClient() {\n    if (!this.options.clientFactory) {\n      throw new Error('clientFactory needs to be provided when initializing GraphQL client.');\n    }\n    return this.options.clientFactory({\n      debugger: debug_1.default.dictionary,\n      retries: this.options.retries,\n      retryStrategy: this.options.retryStrategy\n    });\n  }\n}\nexports.GraphQLDictionaryService = GraphQLDictionaryService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}