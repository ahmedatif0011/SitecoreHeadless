{"ast":null,"code":"'use strict';\n\nfunction Cache() {\n  var _cache = Object.create(null);\n  var _hitCount = 0;\n  var _missCount = 0;\n  var _size = 0;\n  var _debug = false;\n  this.put = function (key, value, time, timeoutCallback) {\n    if (_debug) {\n      console.log('caching: %s = %j (@%s)', key, value, time);\n    }\n    if (typeof time !== 'undefined' && (typeof time !== 'number' || isNaN(time) || time <= 0)) {\n      throw new Error('Cache timeout must be a positive number');\n    } else if (typeof timeoutCallback !== 'undefined' && typeof timeoutCallback !== 'function') {\n      throw new Error('Cache timeout callback must be a function');\n    }\n    var oldRecord = _cache[key];\n    if (oldRecord) {\n      clearTimeout(oldRecord.timeout);\n    } else {\n      _size++;\n    }\n    var record = {\n      value: value,\n      expire: time + Date.now()\n    };\n    if (!isNaN(record.expire)) {\n      record.timeout = setTimeout(function () {\n        _del(key);\n        if (timeoutCallback) {\n          timeoutCallback(key, value);\n        }\n      }.bind(this), time);\n    }\n    _cache[key] = record;\n    return value;\n  };\n  this.del = function (key) {\n    var canDelete = true;\n    var oldRecord = _cache[key];\n    if (oldRecord) {\n      clearTimeout(oldRecord.timeout);\n      if (!isNaN(oldRecord.expire) && oldRecord.expire < Date.now()) {\n        canDelete = false;\n      }\n    } else {\n      canDelete = false;\n    }\n    if (canDelete) {\n      _del(key);\n    }\n    return canDelete;\n  };\n  function _del(key) {\n    _size--;\n    delete _cache[key];\n  }\n  this.clear = function () {\n    for (var key in _cache) {\n      clearTimeout(_cache[key].timeout);\n    }\n    _size = 0;\n    _cache = Object.create(null);\n    if (_debug) {\n      _hitCount = 0;\n      _missCount = 0;\n    }\n  };\n  this.get = function (key) {\n    var data = _cache[key];\n    if (typeof data != \"undefined\") {\n      if (isNaN(data.expire) || data.expire >= Date.now()) {\n        if (_debug) _hitCount++;\n        return data.value;\n      } else {\n        // free some space\n        if (_debug) _missCount++;\n        _size--;\n        delete _cache[key];\n      }\n    } else if (_debug) {\n      _missCount++;\n    }\n    return null;\n  };\n  this.size = function () {\n    return _size;\n  };\n  this.memsize = function () {\n    var size = 0,\n      key;\n    for (key in _cache) {\n      size++;\n    }\n    return size;\n  };\n  this.debug = function (bool) {\n    _debug = bool;\n  };\n  this.hits = function () {\n    return _hitCount;\n  };\n  this.misses = function () {\n    return _missCount;\n  };\n  this.keys = function () {\n    return Object.keys(_cache);\n  };\n  this.exportJson = function () {\n    var plainJsCache = {};\n\n    // Discard the `timeout` property.\n    // Note: JSON doesn't support `NaN`, so convert it to `'NaN'`.\n    for (var key in _cache) {\n      var record = _cache[key];\n      plainJsCache[key] = {\n        value: record.value,\n        expire: record.expire || 'NaN'\n      };\n    }\n    return JSON.stringify(plainJsCache);\n  };\n  this.importJson = function (jsonToImport, options) {\n    var cacheToImport = JSON.parse(jsonToImport);\n    var currTime = Date.now();\n    var skipDuplicates = options && options.skipDuplicates;\n    for (var key in cacheToImport) {\n      if (cacheToImport.hasOwnProperty(key)) {\n        if (skipDuplicates) {\n          var existingRecord = _cache[key];\n          if (existingRecord) {\n            if (_debug) {\n              console.log('Skipping duplicate imported key \\'%s\\'', key);\n            }\n            continue;\n          }\n        }\n        var record = cacheToImport[key];\n\n        // record.expire could be `'NaN'` if no expiry was set.\n        // Try to subtract from it; a string minus a number is `NaN`, which is perfectly fine here.\n        var remainingTime = record.expire - currTime;\n        if (remainingTime <= 0) {\n          // Delete any record that might exist with the same key, since this key is expired.\n          this.del(key);\n          continue;\n        }\n\n        // Remaining time must now be either positive or `NaN`,\n        // but `put` will throw an error if we try to give it `NaN`.\n        remainingTime = remainingTime > 0 ? remainingTime : undefined;\n        this.put(key, record.value, remainingTime);\n      }\n    }\n    return this.size();\n  };\n}\nmodule.exports = new Cache();\nmodule.exports.Cache = Cache;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}