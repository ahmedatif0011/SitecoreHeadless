{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLEditingService = exports.dictionaryQuery = exports.query = void 0;\nconst debug_1 = __importDefault(require(\"../debug\"));\nconst layout_1 = require(\"../layout\");\nconst models_1 = require(\"./models\");\n/**\n * The dictionary query default page size.\n */\nconst PAGE_SIZE = 1000;\n/**\n * GraphQL query for fetching editing data.\n */\nexports.query = `\n query EditingQuery(\n    $siteName: String!\n    $itemId: String!\n    $language: String!\n    $version: String\n    $after: String\n    $pageSize: Int = ${PAGE_SIZE}\n) {\n    item(path: $itemId, language: $language, version: $version) {\n      rendered\n    }\n    site {\n      siteInfo(site: $siteName) {\n        dictionary(language: $language, first: $pageSize, after: $after) {\n          results {\n            key\n            value\n          }\n          pageInfo {\n            endCursor\n            hasNext\n          }\n        }\n      }\n    }\n  }\n`;\n/**\n * GraphQL query for fetching dictionary data.\n * This query is used when the dictionary data is paginated.\n */\nexports.dictionaryQuery = `\n  query EditingDictionaryQuery(\n    $siteName: String!\n    $language: String!\n    $after: String\n    $pageSize: Int = ${PAGE_SIZE}\n  ) {\n    site {\n      siteInfo(site: $siteName) {\n        dictionary(language: $language, first: $pageSize, after: $after) {\n          results {\n            key\n            value\n          }\n          pageInfo {\n            endCursor\n            hasNext\n          }\n        }\n      }\n    }\n  }\n`;\n/**\n * Service for fetching editing data from Sitecore using the Sitecore's GraphQL API.\n * Expected to be used in XMCloud Pages preview (editing) Metadata Edit Mode.\n */\nclass GraphQLEditingService {\n  /**\n   * Fetch layout data using the Sitecore GraphQL endpoint.\n   * @param {GraphQLLayoutServiceConfig} serviceConfig configuration\n   */\n  constructor(serviceConfig) {\n    this.serviceConfig = serviceConfig;\n    this.graphQLClient = this.getGraphQLClient();\n  }\n  /**\n   * Fetches editing data. Provides the layout data and dictionary phrases\n   * @param {object} variables - The parameters for fetching editing data.\n   * @param {string} variables.siteName - The site name.\n   * @param {string} variables.itemId - The item id (path) to fetch layout data for.\n   * @param {string} variables.language - The language to fetch layout data for.\n   * @param {string} [variables.version] - The version of the item (optional).\n   * @param {LayoutKind} [variables.layoutKind] - The final or shared layout variant.\n   * @returns {Promise} The layout data and dictionary phrases.\n   */\n  fetchEditingData(_a) {\n    return __awaiter(this, arguments, void 0, function* ({\n      siteName,\n      itemId,\n      language,\n      version,\n      layoutKind = models_1.LayoutKind.Final\n    }) {\n      var _b, _c, _d, _e, _f;\n      debug_1.default.editing('fetching editing data for %s %s %s %s', siteName, itemId, language, version, layoutKind);\n      if (!siteName) {\n        throw new RangeError('The site name must be a non-empty string');\n      }\n      if (!language) {\n        throw new RangeError('The language must be a non-empty string');\n      }\n      const dictionary = {};\n      let dictionaryResults = [];\n      let hasNext = true;\n      let after = '';\n      const editingData = yield this.graphQLClient.request(exports.query, {\n        siteName,\n        itemId,\n        version,\n        language\n      }, {\n        headers: {\n          sc_layoutKind: layoutKind\n        }\n      });\n      if ((_c = (_b = editingData === null || editingData === void 0 ? void 0 : editingData.site) === null || _b === void 0 ? void 0 : _b.siteInfo) === null || _c === void 0 ? void 0 : _c.dictionary) {\n        dictionaryResults = editingData.site.siteInfo.dictionary.results;\n        hasNext = editingData.site.siteInfo.dictionary.pageInfo.hasNext;\n        after = editingData.site.siteInfo.dictionary.pageInfo.endCursor;\n      } else {\n        hasNext = false;\n      }\n      while (hasNext) {\n        const data = yield this.graphQLClient.request(exports.dictionaryQuery, {\n          siteName,\n          language,\n          after\n        });\n        if ((_e = (_d = data === null || data === void 0 ? void 0 : data.site) === null || _d === void 0 ? void 0 : _d.siteInfo) === null || _e === void 0 ? void 0 : _e.dictionary) {\n          dictionaryResults = dictionaryResults.concat(data.site.siteInfo.dictionary.results);\n          hasNext = data.site.siteInfo.dictionary.pageInfo.hasNext;\n          after = data.site.siteInfo.dictionary.pageInfo.endCursor;\n        } else {\n          hasNext = false;\n        }\n      }\n      dictionaryResults.forEach(item => dictionary[item.key] = item.value);\n      return {\n        layoutData: ((_f = editingData === null || editingData === void 0 ? void 0 : editingData.item) === null || _f === void 0 ? void 0 : _f.rendered) || {\n          sitecore: {\n            context: {\n              pageEditing: true,\n              language,\n              editMode: layout_1.EditMode.Metadata\n            },\n            route: null\n          }\n        },\n        dictionary\n      };\n    });\n  }\n  /**\n   * Gets a GraphQL client that can make requests to the API.\n   * @returns {GraphQLClient} implementation\n   */\n  getGraphQLClient() {\n    if (!this.serviceConfig.clientFactory) {\n      throw new Error('clientFactory needs to be provided when initializing GraphQL client.');\n    }\n    return this.serviceConfig.clientFactory({\n      debugger: debug_1.default.editing,\n      headers: {\n        sc_editMode: 'true'\n      }\n    });\n  }\n}\nexports.GraphQLEditingService = GraphQLEditingService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}