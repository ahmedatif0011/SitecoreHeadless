"use strict";(self.webpackChunkbmexchangerate=self.webpackChunkbmexchangerate||[]).push([[840],{8459:(c,o,a)=>{a.r(o),a.d(o,{StyleguideAngularLazyLoadingModule:()=>u});var s=a(4770),e=a(3279),l=a(3531);let d=(()=>{class n{rendering;constructor(){}static \u0275fac=function(t){return new(t||n)};static \u0275cmp=e.VBU({type:n,selectors:[["app-styleguide-angular-lazy-loading"]],inputs:{rendering:"rendering"},decls:13,vars:1,consts:[[3,"rendering"]],template:function(t,g){1&t&&(e.j41(0,"app-styleguide-specimen",0)(1,"p"),e.EFF(2,"JSS can "),e.j41(3,"em"),e.EFF(4,"lazy-load"),e.k0s(),e.EFF(5," Angular components. This removes them from the main app JS bundle, reducing its size. Lazy-loading is very good for components that are used on few routes, since they are not downloaded until used on a route. This can greatly improve initial page load times."),e.k0s(),e.j41(6,"p"),e.EFF(7,"This works very similarly to route-based Angular lazy-loading, but for an individual component. The component has its own Angular module defined for it, and the loader is added as lazy instead."),e.k0s(),e.j41(8,"p"),e.EFF(9,"To see this lazy loading working, inspect network traffic in your browser's dev tools, and look for "),e.j41(10,"code"),e.EFF(11,"styleguide-angular-lazy-loading-styleguide-angular-lazy-loading-module.js"),e.k0s(),e.EFF(12," (in production mode, the file name will be hash value), which is the request that loads this component's JS."),e.k0s()()),2&t&&e.Y8G("rendering",g.rendering)},dependencies:[l.j],encapsulation:2})}return n})();var r=a(3846);let u=(()=>{class n{static \u0275fac=function(t){return new(t||n)};static \u0275mod=e.$C({type:n});static \u0275inj=e.G2t({imports:[s.d.forChild(d),r.h]})}return n})()}}]);